---
title: 不可变性重访
description: 不可变性重访
---

import AppJsCode from "./code/App.js.example";

<Accordions>

<Accordion title="视频摘要">

在这个模块中，我们将解决 React 中一些最棘手的部分，比如记忆化和 useEffect 钩子。要理解这些著名的难题，拥有对 React 核心机制的扎实理解非常有帮助！

为此，我创建了一个交互式工具（见下文），它展示了在我们创建和更新内容时，状态是如何存储在计算机内存中的。

我们有一个单一的状态变量， user ，它持有一个对象， \{ name: 'Ivy' } 。

在普通的 JavaScript 中，我们可以通过写 user.name = 'Ava' 来更新用户的名称。但这是一种变更！在 React 中我们不应该改变状态。

在 React 中，我们通过运行 setUser(\{ name: 'Ava' }) 来实现。

每次我这样做时，我都会创建一个全新的对象，存放在计算机内存中的一个独特位置。我不是在编辑旧的 \{ name: 'Ivy' } 对象，也不是在用新的对象替换旧的对象。至少在短时间内，这两个对象都会存在。

每个快照都有自己的 user 变量，因此我们可以将其视为两个局部作用域的 user 变量，它们各自指向不同的对象。

在实际操作中，JS 垃圾收集器会清理旧对象，因此我们不必担心内存不足。

在 JavaScript 中，对象是通过引用存储的。我们可以有两个看起来相同的对象，比如 \{ name: 'Ava' } 和 \{ name: 'Ava' } ，但如果我们分别创建它们，它们就是不同的实体，就像同卵双胞胎。

如果我们有多个状态变量呢？例如，假设我们还有一个 items 状态变量，它保存一个数字数组。

当我们使用 setUser() 创建新的快照，更新 user 对象时，我们重用 items 数组。

每个快照将创建一个新的 items 变量，但所有这些变量都将指向相同的基础数组。我们的内存中只有 1 个数组，它被线程传递给每个快照。

这很重要，因为它允许 React 识别状态变量何时实际上发生了变化。当我们学习 useEffect 和 useMemo / useCallback 时，我们将看到这的影响。

下面，您会找到一个沙盒，用于重现此可视化。您可以通过打开开发者工具并记录 window.stateValues 来记录所有状态值的值。在运行任何控制台指令之前，请确保选择 josh-bundler iframe。

</Accordion>

</Accordions>

这是视频中的可视化。您可以通过“”图标将可视化重置为初始状态。(没办法复现, 仅图片)

![screenshot-20250228-095805](/react/module3/screenshot-20250228-095805.png)

这是视频中的沙盒，展示了代码是如何工作的：

<Sandpack
  files={{
    "App.js": AppJsCode,
  }}
  template="react"
/>

## 这些快照究竟是什么？

在上面的演示中，我展示了“快照”，它们以卡片的形式出现，包含状态的片段。

在本课程中，我使用“快照”一词来表示执行渲染的结果。这是两件事的结合：

1. 渲染发生时任何属性/状态的具体值
2. 从组件返回的 React 元素，描述在渲染中计算的 UI。

我上面的演示没有显示元素，因为我们专注于状态。

值得回顾一下第二模块的“核心 React 循环”课程。我们会更深入地探讨这个想法！

您可能还会想知道：快照和实例之间有什么区别？

正如我们在“组件实例”课程中所学的，组件实例是一个 JavaScript 对象，它是与组件的特定实例相关的所有内容的“真相来源”。当组件挂载时创建它，并且它在组件卸载之前一直存在。

快照，相较之下，并不是一个特定的 JavaScript 对象。它是一个更抽象/隐喻的概念。它指的是某一时刻可用的数据。

所以，我们可以说一个实例持有一个状态的真实值，但每当该状态改变时，我们会创建一个快照，捕捉该状态变量的当前值。

我意识到在本课程中我给你们介绍了很多术语：组件、元素、实例和快照。如果这些概念在你脑中并没有完全明了也没关系！我们的目标是随着我们对 React 的了解越来越多，逐渐建立对我们理解的信心。

React 文档也可以帮助巩固这些内容。查看“[State as a Snapshot](https://react.dev/learn/state-as-a-snapshot)”。
